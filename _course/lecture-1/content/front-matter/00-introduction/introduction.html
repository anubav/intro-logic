<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to Logic - Introduction</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../index.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../../site_libs/quarto-contrib/lproof-1.0.0/lproof.js"></script>
<link href="../../../site_libs/quarto-contrib/lproof-1.0.0/lproof.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<script src="../../../assets/scripts/definitions.js"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../assets/styles/fonts.css">
<link rel="stylesheet" href="../../../assets/styles/environments.css">
<link rel="stylesheet" href="../../../assets/styles/tweaks.css">
<link rel="stylesheet" href="../../../assets/styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../content/front-matter/00-introduction/introduction.html">Introduction</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">Introduction to Logic</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Front Matter</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/front-matter/00-introduction/introduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#why-study-logic" id="toc-why-study-logic" class="nav-link active" data-scroll-target="#why-study-logic">Why Study Logic?</a>
  <ul class="collapse">
  <li><a href="#berrys-paradoxberry" id="toc-berrys-paradoxberry" class="nav-link" data-scroll-target="#berrys-paradoxberry">Berry’s Paradox</a></li>
  <li><a href="#the-surprise-exam-paradoxsurprise-exam" id="toc-the-surprise-exam-paradoxsurprise-exam" class="nav-link" data-scroll-target="#the-surprise-exam-paradoxsurprise-exam">The Surprise Exam Paradox</a></li>
  <li><a href="#the-sorites-paradoxsorites" id="toc-the-sorites-paradoxsorites" class="nav-link" data-scroll-target="#the-sorites-paradoxsorites">The Sorites Paradox</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="why-study-logic" class="level2">
<h2 class="anchored" data-anchor-id="why-study-logic">Why Study Logic?</h2>
<p>Logic is one of the few subjects to appear on nearly every philosophy curriculum worldwide. A student who is new to the subject may naturally wonder why this should be the case. Why, that is, should the study of logic be regarded as a necessary prerequisite to a philosophical education? Puzzlement on this score is sure to increase when, upon first entry into the study of logic, one is almost immediately confronted with formulas and equations that seem more at home in a course of mathematics than philosophy.</p>
<p>One potential source of confusion as to logic’s proper place within philosophy derives from the fact that what might be termed <em>logicality</em>—or the capacity to reason well—is no more necessary an intellectual virtue for the philosopher than it is for, say, the chemist, the historian, or the statistician. And yet in other disciplines one does not find logic being taught as its own subject. History students, for example, are expected to acquire a working knowledge of what counts as sound historical reasoning not through any direct instruction as to the principles of logic that apply in their field, but instead by studying the work of professional historians and undertaking to produce such work on their own. Indeed, even in the domain of mathematics, where sound reasoning is arguably constitutive of the discipline and not merely an aspect of its methodology, students, by and large, are provided with no special training in logic. Instead, a working knowledge of the methods of proof by which mathematicians establish theorems is viewed as a natural byproduct of a proper mathematical education.</p>
<p>Why then do philosophers approach the study of logic so differently? Why do they treat logic as having its own distinctive subject matter and not merely as a part of philosophical methodology? The answer, in short, is that reasoning, or argumentation, is not merely something that philosophers do and aspire to do well. It is also among the principal <em>objects</em> of philosophical scrutiny.</p>
<p>There is no more recognizably philosophical form of intellectual activity as that which results from the attempt to resolve the feeling of paradox that accompanies an apparently sound argument which leads to a manifestly absurd conclusion. For the philosopher, such paradoxes of reasoning are not merely something to be avoided in practice—which perhaps would be simple enough to achieve—they are also sources of potential insight. For they highlight the need for a more careful scrutiny of the various concepts implicated in our reasonings. Consider, for example, the following paradoxes, each of which has been made the subject of logical analysis and subsequently served as the starting point for a rich and fruitful line of philosophical inquiry:</p>
<div id="berry" class="example">
<section id="berrys-paradoxberry" class="level3">
<h3 class="anchored" data-anchor-id="berrys-paradoxberry">Berry’s Paradox<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h3>
<p>There are twenty-six letters in the English alphabet. Ignoring letter case and punctuation, and admitting one additional character to mark both the space between words and leading and trailing spaces, there are <span class="math inline">\(27^{79}\)</span> expressions with fewer than eighty characters. The vast majority of these expressions will be nonsense expressions like: <span class="math display">\[
\textrm{asdlkjsdl goiwejrkwmfw sdsf se asfsd f}
\]</span> A few will be intelligible noun phrases, such as: <span class="math display">\[
\textrm{The tallest building in Chicago}
\]</span> or: <span class="math display">\[
\textrm{The present king of France}
\]</span> A much smaller selection still will be noun phrases denoting positive integers, for example: <span class="math display">\[
\textrm{The sum of twelve and seventeen}
\]</span> or: <span class="math display">\[
\textrm{The first prime number which exceeds the number of stars in the Milky Way}
\]</span></p>
<p>Now, consider the class of all the positive integers denoted by expressions with fewer than eighty characters. Since the number of such expressions is finite, so too must be the class of positive integers they collectively denote. Hence, this class of positive integers, being finite, must have a largest member. Let this number be <span class="math inline">\(N\)</span>. It follows that <span class="math inline">\(N+1\)</span> is the smallest positive integer not describable with fewer than eighty characters. But, if so, then <span class="math inline">\(N+1\)</span> <em>is</em> describable with fewer than eighty characters, namely, by the phrase: <span class="math display">\[
\textrm{The smallest positive integer not describable with fewer than eighty
characters} \]</span></p>
<p>Thus, it seems, the number <span class="math inline">\(N+1\)</span> is both describable and not describable with fewer than eighty characters, which is a contradiction.</p>
</section>
</div>
<div id="surprise" class="example">
<section id="the-surprise-exam-paradoxsurprise-exam" class="level3">
<h3 class="anchored" data-anchor-id="the-surprise-exam-paradoxsurprise-exam">The Surprise Exam Paradox<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h3>
<p>A teacher announces to one of his students prior to the first meeting of class that at some point during the term the student will be given a surprise exam. The student replies to the teacher’s announcement by giving the following argument purporting to show that what the teacher has said cannot be true:</p>
<blockquote class="blockquote">
<p>The surprise exam cannot be given on the last day of class. For if this were so then just prior to the last class, having attended all but the last day of class without receiving the exam, I would know that the exam will be administered that day, in which case it will not be a surprise. Neither, however, can the exam be given on the next-to-last day of class. For if this were so then just prior to the next-to-last class, having attended all but the last two days of class without receiving the exam and having already concluded that the exam cannot be given on the last day, I would know that the exam will be administered that day, in which case it will not be a surprise. Continuing in this way, it follows that no matter when the exam is given it cannot be a surprise.</p>
</blockquote>
<p>The conclusion of the student’s argument is absurd since it is clearly possible for the teacher to administer one and only one surprise exam (on, say, the third day of class).</p>
</section>
</div>
<div id="sorites" class="example">
<section id="the-sorites-paradoxsorites" class="level3">
<h3 class="anchored" data-anchor-id="the-sorites-paradoxsorites">The Sorites Paradox<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></h3>
<p>Some aggregations of sand are sufficiently numerous to constitute a heap, while others are not. And yet it is a feature of the property of being a heap that whether or not a particular aggregation of sand is a heap is unchanged by the addition or removal of a single grain. Now, consider a numerous enough aggregation of sand as to clearly constitute a heap. Remove from this heap one grain of sand at a time and ask at each stage of the process whether what remains is still a heap. If being a heap is always unchanged by the removal of a single grain of sand, then at each stage of the process, the heap remains a heap and the question ought to be answered in the affirmative. But, if we continue such reasoning for long enough, it will follow that even a few grains of sand constitute a heap, which is absurd.</p>
</section>
</div>
<p>Later on in this course, we will have occasion to revisit each of these paradoxes, and discuss them in more detail. For now, let us focus on the last example of the <a href="#sorites" class="unstyled-link">sorites paradox</a>, as it can be used to illustrate how philosopher’s employ the method of logical analysis to treat paradoxes of reasoning.</p>
<p>When confronted by a paradox, the question one must ask is: where has the reasoning gone wrong? As a first step towards answering this question, it is natural to try to identify the principle assumptions that are being relied upon in the fallacious argument. In the case of the sorites paradox, the fallacy relies on the fact that there are certain properties—such as that of being a heap—which seem to exhibit the following features:</p>
<ol type="1">
<li><p>Whether or not the property applies is invariant under small changes in the object to which it is applied.</p></li>
<li><p>A large enough number of such small changes, if carried out in consecution, would result in a sequence of objects the first of which clearly possesses the property and the last of which clearly does not.</p></li>
</ol>
<p>Identifying the core assumptions at work in a fallacy is a good start, but one must next explain how exactly these assumptions are utilized in the paradoxical argument to underwrite the fallacious conclusion. It is at this stage of the analysis that one typically resorts to the formalisms of logic to represent the reasoning more precisely.</p>
<p>Let <span class="math inline">\(H\)</span> (for “heap”) be a predicate which applies to the positive integers (<span class="math inline">\(1,2,3,\ldots\)</span>) and which is defined as follows: <span class="math display">\[
  H(n) \textrm{ iff an accumulation of $n$ grains of sand is a heap}
\]</span></p>
<p>Let <span class="math inline">\(l\)</span> be a large enough number such that <span class="math inline">\(H(l)\)</span> is clearly true and let <span class="math inline">\(s\)</span> be a small enough number such that <span class="math inline">\(H(s)\)</span> is clearly false. Then, the paradoxical line of reasoning outlined above can be represented as follows:</p>
<div class="lproof">
<div class="proof-line" data-number="1" data-depth="0">
<span class="line-number"><span class="math inline">\(1\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{For all }n&gt;1\textrm{: if }H(n)\textrm{, then } H(n-1).\)</span></span>
<span class="proof-justification">assumption</span>
</div>
<div class="proof-line" data-number="2" data-depth="0">
<span class="line-number"><span class="math inline">\(2\)</span></span>
<span class="proof-formula"><span class="math inline">\(H(l)\)</span></span>
<span class="proof-justification">assumption</span>
</div>
<div class="proof-line" data-number="3" data-depth="0" data-crossrefs="1">
<span class="line-number"><span class="math inline">\(3\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{If }H(l)\textrm{, then }H(l-1)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(1\)</span></span>
</div>
<div class="proof-line" data-number="4" data-depth="0" data-crossrefs="2,3">
<span class="line-number"><span class="math inline">\(4\)</span></span>
<span class="proof-formula"><span class="math inline">\(H(l-1)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(2, 3\)</span></span>
</div>
<div class="proof-line" data-number="5" data-depth="0" data-crossrefs="1">
<span class="line-number"><span class="math inline">\(5\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{If }H(l-1)\textrm{, then }H(l-2)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(1\)</span></span>
</div>
<div class="proof-line" data-number="6" data-depth="0" data-crossrefs="4,5">
<span class="line-number"><span class="math inline">\(6\)</span></span>
<span class="proof-formula"><span class="math inline">\(H(l-2)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(4, 5\)</span></span>
</div>
<div class="proof-line" data-number="7" data-depth="0" data-ellipses="true">
<span class="line-number"><span class="math display">\[\vdots\]</span></span>
<span class="proof-formula"></span>
<span class="proof-justification"></span>
</div>
<div class="proof-line" data-number="8" data-depth="0" data-crossrefs="1">
<span class="line-number"><span class="math inline">\(n\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{If }H(s+1)\textrm{, then }H(s)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(1\)</span></span>
</div>
<div class="proof-line" data-number="9" data-depth="0">
<span class="line-number"><span class="math inline">\(n+1\)</span></span>
<span class="proof-formula"><span class="math inline">\(H(s)\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(n-1, n\)</span></span>
</div>
</div>
<div id="exr-line-number" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1</strong></span> Express the line number <span class="math inline">\(n\)</span> in terms of <span class="math inline">\(l\)</span> and <span class="math inline">\(s\)</span>.</p>
</div>
<p>What is important about this representation of the reasoning is not the symbolic shorthand it utilizes but rather the clear separation it effects between the assumptions presupposed in the reasoning, given in lines 1 and 2 of the argument, and the patterns of reasoning employed to deduce from these assumptions the counterintuitive conclusion.</p>
<p>This general procedure whereby the material assumptions upon which an argument relies are made explicit and distinguished from the form of the reasoning involved in the argument, may be termed <em>logical analysis</em>. The methodological value of logical analysis for philosophy resides in the asymmetrical status that is generally afforded to the truth of the material assumptions, which may be questioned, and the underlying system of formal logic on which the argument is based, which is generally taken to be beyond reproach. If our analysis of an argument represents the reasoning as valid in a correct system of logic, then the fault in the reasoning must lie with one of the material assumptions.</p>
<p>Of the two assumptions appearing in the sorites paradox, only the first, given in line 1 of the above argument, seems susceptible to doubt, and, indeed, many philosophers have claimed that, contrary to first appearances, it is, in fact, false. To accept such a claim, of course, one must rebut any argument which attempts to derive from the denial of the rejected assumption a further objectionable conclusion. One such argument discussed in the philosophical literature is the following:</p>
<div class="lproof">
<div class="proof-line" data-number="1" data-depth="0">
<span class="line-number"><span class="math inline">\(1\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{It is not true that: for all }n&gt;1\textrm{, if }H(n)\textrm{, then } H(n-1).\)</span></span>
<span class="proof-justification">assumption</span>
</div>
<div class="proof-line" data-number="2" data-depth="0" data-crossrefs="1">
<span class="line-number"><span class="math inline">\(2\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{It is true that: for some }n&gt;1\textrm{, }H(n)\textrm{ but not } H(n-1).\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(1\)</span></span>
</div>
<div class="proof-line" data-number="3" data-depth="0" data-crossrefs="2">
<span class="line-number"><span class="math inline">\(3\)</span></span>
<span class="proof-formula"><span class="math inline">\(\textrm{For some }n&gt;1\textrm{, it is true that: }H(n)\textrm{ but not } H(n-1).\)</span></span>
<span class="proof-justification">from: <span class="math inline">\(2\)</span></span>
</div>
</div>
<p>The conclusion of this argument seems unacceptable. There simply cannot be a specific number <span class="math inline">\(n\)</span> such that <span class="math inline">\(n\)</span> grains of sand constitute a heap, but <span class="math inline">\(n-1\)</span> grains of sand do not. If this is correct, then the above argument must be invalid, and the fault must lie with either the inference from line 1 to 2, or the inference from line 2 to 3. Either response introduces a variety of logical subtleties, but each has its defenders in the literature.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Suppose, however, that upon due reflection we find such considerations unconvincing and that we can discover no other satisfactory reason to reject any of the material assumptions which lead to the sorites paradox. Must we then admit what seems patently absurd, that only a few grains of sand consitute a heap? We are only compelled to accept this absurdity, if we acknowledge as valid the form of the argument by which this seemingly absurd conclusion was derived from the premises we now admit to be true. But nothing in philosophy is sacrosanct—not even logic—and alternative resolutions to the sorites paradox have been put forward which target the underlying form of the reasoning itself. One such approach, for example, involves building into our system of logic a constraint which restricts the number of claims of the form ‘<span class="math inline">\(\textrm{If }H(n)\textrm{, then
}H(n-1)\)</span>’ that can be appealed to in any single argumentative context.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> According to this approach, the paradoxical argument fails not because of the falsehood of one of its material assumptions but because any chain of reasoning long enough to extend from a heap to a handful of grains of sand is simply too long for the argument to count as valid.</p>
<p>The possibility of such revisionary logical critique might seem to call into question the value of undertaking a detailed study of any specific system of logic before first assessing its adequacy. However, there are certain systems of logic which, despite their limitations, have proven to be so powerful in their applications that they have come to be regarded as a sort-of ‘starter’s toolkit’ for logical analysis. These systems of logic include classical propositional logic, first-order quantificational logic, and the normal modal extensions thereof. A great deal of conceptual insight can be gained simply by formalizing arguments as derivations in these systems, and one can be certain that any proposed solution to a philosophical problem which calls for a significant revision to one of these systems is venturing into deep philosophical waters. Before daring such depths, it is therefore essential for any student of analytic philosophy to gain facility in working with these standard systems of logic and to come to understand both their inherent capacities and limitations. This is what we hope to achieve in this course.</p>
<div id="exr-outside-reading" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2</strong></span> Read one of the articles listed in the <a href="#references">References</a> section of this Introduction.</p>
</div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Boolos1989-cs" class="csl-entry" role="listitem">
Boolos, George. 1989. <span>“A New Proof of the Godel Incompleteness Theorem.”</span> <em>Notices of the American Mathematical Society</em> 36: 388–90.
</div>
<div id="ref-Fine1975-cq" class="csl-entry" role="listitem">
Fine, Kit. 1975. <span>“Vagueness, Truth and Logic.”</span> <em>Synthese</em> 30: 265–300.
</div>
<div id="ref-Gaifman2010-rk" class="csl-entry" role="listitem">
Gaifman, Haim. 2010. <span>“Vagueness, Tolerance and Contextual Logic.”</span> <em>Synthese</em> 174: 5–46.
</div>
<div id="ref-Gardner1991-un" class="csl-entry" role="listitem">
Gardner, Martin. 1991. <em>The Unexpected Hanging and Other Mathematical Diversions</em>. University of Chicago Press.
</div>
<div id="ref-Keefe2000-gn" class="csl-entry" role="listitem">
Keefe, Rosanna. 2000. <em>Theories of Vagueness</em>. Cambridge University Press.
</div>
<div id="ref-Kripke2011-ny" class="csl-entry" role="listitem">
Kripke, Saul. 2011. <span>“On Two Paradoxes of Knowledge.”</span> In <em>Philosophical Troubles, Collected Papers</em>. Vol. I. Oxford University Press.
</div>
<div id="ref-Putnam1983-ix" class="csl-entry" role="listitem">
Putnam, Hilary. 1983. <span>“Vagueness and Alternative Logic.”</span> <em>Erkenntnis</em> 19: 297–314.
</div>
<div id="ref-Quine1953-cz" class="csl-entry" role="listitem">
Quine, Willard Van Orman. 1953. <span>“On a so-Called Paradox.”</span> <em>Mind; a Quarterly Review of Psychology and Philosophy</em> 62: 65–67.
</div>
<div id="ref-Russell1908-fs" class="csl-entry" role="listitem">
Russell, Bertrand. 1908. <span>“Mathematical Logic as Based on the Theory of Types.”</span> <em>American Journal of Mathematics</em> 30: 222–62.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>The first presentation of Berry’s Paradox appears in <span class="citation" data-cites="Russell1908-fs">Russell (<a href="#ref-Russell1908-fs" role="doc-biblioref">1908</a>)</span>. <span class="citation" data-cites="Boolos1989-cs">Boolos (<a href="#ref-Boolos1989-cs" role="doc-biblioref">1989</a>)</span> presents a concise proof of Gödel’s incompleteness result based on a formalization of Berry’s Paradox.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The surprise exam paradox, originally described as the paradox of the “unexpected hanging”, first appeared in Martin Gardner’s March 1963 Mathematical Games column in Scientific American magazine (reprinted in <span class="citation" data-cites="Gardner1991-un">Gardner (<a href="#ref-Gardner1991-un" role="doc-biblioref">1991</a>)</span>). Philosophical discussions of the paradox appear in <span class="citation" data-cites="Quine1953-cz">Quine (<a href="#ref-Quine1953-cz" role="doc-biblioref">1953</a>)</span> and <span class="citation" data-cites="Kripke2011-ny">Kripke (<a href="#ref-Kripke2011-ny" role="doc-biblioref">2011</a>)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The name <em>sorites</em> derives from the Greek σωρός meaning “heap” (as in a heap of sand). The paradox is attributed to Eubulides (4th c.&nbsp;BCE) of Miletus, a philosopher of the Megarian school. It has since become a central topic of discussion in the philosophy of language and logic, and has inspired a vast literature on the issue of conceptual vagueness.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>For an analysis of the paradox that rejects the inference from line 1 to 2, noting its invalidity in intuitionistic logic, see <span class="citation" data-cites="Putnam1983-ix">Putnam (<a href="#ref-Putnam1983-ix" role="doc-biblioref">1983</a>)</span>. The most common grounds for rejecting the inference from line 2 to 3 involves the adoption of a supervaluationist semantics such as that described in <span class="citation" data-cites="Fine1975-cq">Fine (<a href="#ref-Fine1975-cq" role="doc-biblioref">1975</a>)</span> and <span class="citation" data-cites="Keefe2000-gn">Keefe (<a href="#ref-Keefe2000-gn" role="doc-biblioref">2000</a>)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>One proposal for how to develop such a logic is given in <span class="citation" data-cites="Gaifman2010-rk">Gaifman (<a href="#ref-Gaifman2010-rk" role="doc-biblioref">2010</a>)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../index.html" class="pagination-link" aria-label="Front Matter">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Front Matter</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>